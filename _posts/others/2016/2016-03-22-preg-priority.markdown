---
layout: post
title:  正则笔记
date:   2016-03-22 21:23:10 +0800
categories: others
---
网上说了千篇一律的就不说了, 这里说说需要pay attention的地方

1. 当 . | 等用在 [ ] 里面的时候, 它意思仅代表 符号"." 和 符号 "|"

2.在php 如果要匹配 \, 则要使用四个\, 即\\\\

7.有些字符如 第四声的a
    在unicode中由两个代码点组成, U+0061 (a) 和钝重音 U+0300 (') 组成, 结果 就是 /./无法匹配, 而/../可以匹配
8.\unum 只支持4位
   \xnum 支持任意数目, 特别是新出的音乐谱号C

   9.使用\Q...\E , 中间的元字符将不再起作用, . 匹配 ., * 匹配 *

   . 不能匹配null

   11. \p{L} 匹配所有字母
      \p{M} 匹配不能单独出现, 而必须与其他基本字符一起出现(重音符号,包围框等等)的字符
      \p{Z} 用于表示分隔, 但本身不可见的字符 (各种空白字符)   (不可匹配圆角字符)
      \p{S} 各种图形符号 和 字母符号  (如 +)
      \p{P} 标点符号
      \p{C} 匹配其他任何字符

13. \G 的特点, 匹配上一次匹配结束的位置
      1) 如果用了多个正则表达式, 后续的正则可以使用这个位置
      2) (php 中似乎每次都指向了开头位置)


      \g 后项引用, 从后面倒着数
      (foo)(bar)\g{-1}

21. 正则有两种引擎, DFA 和 NFA
      NFA (非确定型有穷自动机)   表达式主导, 历史更长, 使用者包括.net, java, php, python, perl, sed等
      DFA (确定型有穷自动机)      文本主导,     匹配速度快, 匹配一致, 用起来很恼人 使用者有 eregp, awk, MySQL等
      
      如何区分?
      1)首先看是否忽略优先量词, 如果是则是 传统型NFA, DFA 不支持, POSIX NFA中也没有意义 (.*?)
                使用 /if|if.not/  匹配 if not, 如果匹配了if, 则是传统型NFA, 如果匹配了if not则是其它
      2)DFA 不支持捕获型括号和回溯

      区别
      1)DFA 会匹配最长的, 而NFA匹配最左的, POSIX NFA会选取最左边开始的最长匹配, 如:
                       abcdefg     a|ab|abc|abcd                abcde   (a)?(ab)?
         DFA             得到 abcd                                          得到ab
         NFA             得到 a                                               得到a

      速度:
      1)DFA速度与正则表达式无关, 而NFA直接相关
      2)DFA会提供更好的预编译, 术语为延迟求值, 不过预编译大部分都是白费功夫

      能力:
      1)捕获括号
      2)环视
      3)非匹配优先量词, 有序的多选结构(这俩其实一样)
      4)占有优先量词, 固话分组(这俩其实一样)

      传统型 NFA        功能强大
      POSIX  NFA        符合标准
      DFA                   运转稳定

